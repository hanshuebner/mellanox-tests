require("ffi").cdef[=============[typedef signed char int8_t;
typedef short int int16_t;
typedef int int32_t;

typedef long int int64_t;

typedef unsigned char uint8_t;
typedef unsigned short int uint16_t;

typedef unsigned int uint32_t;

typedef unsigned long int uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;

typedef long int int_least64_t;

typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;

typedef unsigned long int uint_least64_t;
typedef signed char int_fast8_t;

typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;

typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;

typedef unsigned long int uintptr_t;
typedef long int intmax_t;
typedef unsigned long int uintmax_t;

typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;

typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;

typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;

typedef long int __quad_t;
typedef unsigned long int __u_quad_t;

typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct { int __val[2]; } __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;

typedef int __daddr_t;
typedef int __key_t;

typedef int __clockid_t;

typedef void * __timer_t;

typedef long int __blksize_t;

typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;

typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;

typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;

typedef long int __fsword_t;

typedef long int __ssize_t;

typedef long int __syscall_slong_t;

typedef unsigned long int __syscall_ulong_t;

typedef __off64_t __loff_t;
typedef __quad_t *__qaddr_t;
typedef char *__caddr_t;

typedef long int __intptr_t;

typedef unsigned int __socklen_t;

static __inline unsigned int
__bswap_32 (unsigned int __bsx)
{
  return __builtin_bswap32 (__bsx);
}
static __inline __uint64_t
__bswap_64 (__uint64_t __bsx)
{
  return __builtin_bswap64 (__bsx);
}
typedef long unsigned int size_t;

typedef __time_t time_t;

struct timespec
  {
    __time_t tv_sec;
    __syscall_slong_t tv_nsec;
  };

typedef __pid_t pid_t;

typedef union
{
  char __size[40];
  long int __align;
} pthread_mutex_t;

typedef union
{
  char __size[48];
  __extension__ long long int __align;
} pthread_cond_t;

struct ibv_srq_init_attr;
struct ibv_cq;
struct ibv_pd;
struct ibv_qp_init_attr;
struct ibv_qp_attr;
struct ibv_xrc_domain {
 struct ibv_context *context;
 uint32_t handle;
};

struct ibv_srq_legacy {
 struct ibv_context *context;
 void *srq_context;
 struct ibv_pd *pd;
 uint32_t handle;

 uint32_t events_completed;

 uint32_t xrc_srq_num_bin_compat;
 struct ibv_xrc_domain *xrc_domain_bin_compat;
 struct ibv_cq *xrc_cq_bin_compat;

 pthread_mutex_t mutex;
 pthread_cond_t cond;

 void *ibv_srq;

 uint32_t xrc_srq_num;
 struct ibv_xrc_domain *xrc_domain;
 struct ibv_cq *xrc_cq;
};
struct ibv_xrc_domain *ibv_open_xrc_domain(struct ibv_context *context,
        int fd, int oflag) __attribute__((deprecated));
struct ibv_srq *ibv_create_xrc_srq(struct ibv_pd *pd,
       struct ibv_xrc_domain *xrc_domain,
       struct ibv_cq *xrc_cq,
       struct ibv_srq_init_attr *srq_init_attr) __attribute__((deprecated));
int ibv_close_xrc_domain(struct ibv_xrc_domain *d) __attribute__((deprecated));
int ibv_create_xrc_rcv_qp(struct ibv_qp_init_attr *init_attr,
     uint32_t *xrc_rcv_qpn) __attribute__((deprecated));
int ibv_modify_xrc_rcv_qp(struct ibv_xrc_domain *xrc_domain,
     uint32_t xrc_qp_num,
     struct ibv_qp_attr *attr, int attr_mask) __attribute__((deprecated));
int ibv_query_xrc_rcv_qp(struct ibv_xrc_domain *xrc_domain, uint32_t xrc_qp_num,
    struct ibv_qp_attr *attr, int attr_mask,
    struct ibv_qp_init_attr *init_attr) __attribute__((deprecated));
int ibv_reg_xrc_rcv_qp(struct ibv_xrc_domain *xrc_domain,
    uint32_t xrc_qp_num) __attribute__((deprecated));
int ibv_unreg_xrc_rcv_qp(struct ibv_xrc_domain *xrc_domain,
    uint32_t xrc_qp_num) __attribute__((deprecated));

union ibv_gid {
 uint8_t raw[16];
 struct {
  uint64_t subnet_prefix;
  uint64_t interface_id;
 } global;
};
/*static void *__VERBS_ABI_IS_EXTENDED = ((uint8_t *)((void *)0)) - 1;*/

struct ibv_device_attr {
 char fw_ver[64];
 uint64_t node_guid;
 uint64_t sys_image_guid;
 uint64_t max_mr_size;
 uint64_t page_size_cap;
 uint32_t vendor_id;
 uint32_t vendor_part_id;
 uint32_t hw_ver;
 int max_qp;
 int max_qp_wr;
 int device_cap_flags;
 int max_sge;
 int max_sge_rd;
 int max_cq;
 int max_cqe;
 int max_mr;
 int max_pd;
 int max_qp_rd_atom;
 int max_ee_rd_atom;
 int max_res_rd_atom;
 int max_qp_init_rd_atom;
 int max_ee_init_rd_atom;
 int atomic_cap;
 int max_ee;
 int max_rdd;
 int max_mw;
 int max_raw_ipv6_qp;
 int max_raw_ethy_qp;
 int max_mcast_grp;
 int max_mcast_qp_attach;
 int max_total_mcast_qp_attach;
 int max_ah;
 int max_fmr;
 int max_map_per_fmr;
 int max_srq;
 int max_srq_wr;
 int max_srq_sge;
 uint16_t max_pkeys;
 uint8_t local_ca_ack_delay;
 uint8_t phys_port_cnt;
};

struct ibv_port_attr {
 int state;
 int max_mtu;
 int active_mtu;
 int gid_tbl_len;
 uint32_t port_cap_flags;
 uint32_t max_msg_sz;
 uint32_t bad_pkey_cntr;
 uint32_t qkey_viol_cntr;
 uint16_t pkey_tbl_len;
 uint16_t lid;
 uint16_t sm_lid;
 uint8_t lmc;
 uint8_t max_vl_num;
 uint8_t sm_sl;
 uint8_t subnet_timeout;
 uint8_t init_type_reply;
 uint8_t active_width;
 uint8_t active_speed;
 uint8_t phys_state;
 uint8_t link_layer;
 uint8_t reserved;
};

struct ibv_async_event {
 union {
  struct ibv_cq *cq;
  struct ibv_qp *qp;
  struct ibv_srq *srq;
  int port_num;

  uint32_t xrc_qp_num;
 } element;
 int event_type;
};

const char *ibv_wc_status_str(int status);

struct ibv_wc {
 uint64_t wr_id;
 int status;
 int opcode;
 uint32_t vendor_err;
 uint32_t byte_len;
 uint32_t imm_data;
 uint32_t qp_num;
 uint32_t src_qp;
 int wc_flags;
 uint16_t pkey_index;
 uint16_t slid;
 uint8_t sl;
 uint8_t dlid_path_bits;
};

struct ibv_pd {
 struct ibv_context *context;
 uint32_t handle;
};

struct ibv_xrcd_init_attr {
 uint32_t comp_mask;
 int fd;
 int oflags;
};

struct ibv_xrcd {
 struct ibv_context *context;
};


struct ibv_mr {
 struct ibv_context *context;
 struct ibv_pd *pd;
 void *addr;
 size_t length;
 uint32_t handle;
 uint32_t lkey;
 uint32_t rkey;
};

struct ibv_mw {
 struct ibv_context *context;
 struct ibv_pd *pd;
 uint32_t rkey;
};

struct ibv_global_route {
 union ibv_gid dgid;
 uint32_t flow_label;
 uint8_t sgid_index;
 uint8_t hop_limit;
 uint8_t traffic_class;
};

struct ibv_grh {
 uint32_t version_tclass_flow;
 uint16_t paylen;
 uint8_t next_hdr;
 uint8_t hop_limit;
 union ibv_gid sgid;
 union ibv_gid dgid;
};

int ibv_rate_to_mult(int rate) __attribute__((const));

int mult_to_ibv_rate(int mult) __attribute__((const));

int ibv_rate_to_mbps(int rate) __attribute__((const));

int mbps_to_ibv_rate(int mbps) __attribute__((const));

struct ibv_ah_attr {
 struct ibv_global_route grh;
 uint16_t dlid;
 uint8_t sl;
 uint8_t src_path_bits;
 uint8_t static_rate;
 uint8_t is_global;
 uint8_t port_num;
};

struct ibv_srq_attr {
 uint32_t max_wr;
 uint32_t max_sge;
 uint32_t srq_limit;
};

struct ibv_srq_init_attr {
 void *srq_context;
 struct ibv_srq_attr attr;
};

struct ibv_srq_init_attr_ex {
 void *srq_context;
 struct ibv_srq_attr attr;

 uint32_t comp_mask;
 int srq_type;
 struct ibv_pd *pd;
 struct ibv_xrcd *xrcd;
 struct ibv_cq *cq;
};

struct ibv_qp_cap {
 uint32_t max_send_wr;
 uint32_t max_recv_wr;
 uint32_t max_send_sge;
 uint32_t max_recv_sge;
 uint32_t max_inline_data;
};

struct ibv_qp_init_attr {
 void *qp_context;
 struct ibv_cq *send_cq;
 struct ibv_cq *recv_cq;
 struct ibv_srq *srq;
 struct ibv_qp_cap cap;
 int qp_type;
 int sq_sig_all;

 struct ibv_xrc_domain *xrc_domain;
};

struct ibv_qp_init_attr_ex {
 void *qp_context;
 struct ibv_cq *send_cq;
 struct ibv_cq *recv_cq;
 struct ibv_srq *srq;
 struct ibv_qp_cap cap;
 int qp_type;
 int sq_sig_all;

 uint32_t comp_mask;
 struct ibv_pd *pd;
 struct ibv_xrcd *xrcd;
};

struct ibv_qp_open_attr {
 uint32_t comp_mask;
 uint32_t qp_num;
 struct ibv_xrcd *xrcd;
 void *qp_context;
 int qp_type;
};

struct ibv_qp_attr {
 int qp_state;
 int cur_qp_state;
 int path_mtu;
 int path_mig_state;
 uint32_t qkey;
 uint32_t rq_psn;
 uint32_t sq_psn;
 uint32_t dest_qp_num;
 int qp_access_flags;
 struct ibv_qp_cap cap;
 struct ibv_ah_attr ah_attr;
 struct ibv_ah_attr alt_ah_attr;
 uint16_t pkey_index;
 uint16_t alt_pkey_index;
 uint8_t en_sqd_async_notify;
 uint8_t sq_draining;
 uint8_t max_rd_atomic;
 uint8_t max_dest_rd_atomic;
 uint8_t min_rnr_timer;
 uint8_t port_num;
 uint8_t timeout;
 uint8_t retry_cnt;
 uint8_t rnr_retry;
 uint8_t alt_port_num;
 uint8_t alt_timeout;
};

struct ibv_sge {
 uint64_t addr;
 uint32_t length;
 uint32_t lkey;
};

struct ibv_send_wr {
 uint64_t wr_id;
 struct ibv_send_wr *next;
 struct ibv_sge *sg_list;
 int num_sge;
 int opcode;
 int send_flags;
 uint32_t imm_data;
 union {
  struct {
   uint64_t remote_addr;
   uint32_t rkey;
  } rdma;
  struct {
   uint64_t remote_addr;
   uint64_t compare_add;
   uint64_t swap;
   uint32_t rkey;
  } atomic;
  struct {
   struct ibv_ah *ah;
   uint32_t remote_qpn;
   uint32_t remote_qkey;
  } ud;
 } wr;
 union {
  union {
   struct {
    uint32_t remote_srqn;
   } xrc;
  } qp_type;

  uint32_t xrc_remote_srq_num;
 };
};

struct ibv_recv_wr {
 uint64_t wr_id;
 struct ibv_recv_wr *next;
 struct ibv_sge *sg_list;
 int num_sge;
};

struct ibv_mw_bind {
 uint64_t wr_id;
 struct ibv_mr *mr;
 void *addr;
 size_t length;
 int send_flags;
 int mw_access_flags;
};

struct ibv_srq {
 struct ibv_context *context;
 void *srq_context;
 struct ibv_pd *pd;
 uint32_t handle;

 pthread_mutex_t mutex;
 pthread_cond_t cond;
 uint32_t events_completed;

 uint32_t xrc_srq_num_bin_compat_padding;
 struct ibv_xrc_domain *xrc_domain_bin_compat_padding;
 struct ibv_cq *xrc_cq_bin_compat_padding;
 void *ibv_srq_padding;

 uint32_t xrc_srq_num;
 struct ibv_xrc_domain *xrc_domain;
 struct ibv_cq *xrc_cq;
};

struct ibv_qp {
 struct ibv_context *context;
 void *qp_context;
 struct ibv_pd *pd;
 struct ibv_cq *send_cq;
 struct ibv_cq *recv_cq;
 struct ibv_srq *srq;
 uint32_t handle;
 uint32_t qp_num;
 int state;
 int qp_type;

 pthread_mutex_t mutex;
 pthread_cond_t cond;
 uint32_t events_completed;
};

struct ibv_comp_channel {
 struct ibv_context *context;
 int fd;
 int refcnt;
};

struct ibv_cq {
 struct ibv_context *context;
 struct ibv_comp_channel *channel;
 void *cq_context;
 uint32_t handle;
 int cqe;

 pthread_mutex_t mutex;
 pthread_cond_t cond;
 uint32_t comp_events_completed;
 uint32_t async_events_completed;
};

struct ibv_ah {
 struct ibv_context *context;
 struct ibv_pd *pd;
 uint32_t handle;
};

struct ibv_device;
struct ibv_context;

struct ibv_device_ops {
 struct ibv_context * (*alloc_context)(struct ibv_device *device, int cmd_fd);
 void (*free_context)(struct ibv_context *context);
};

enum {
 IBV_SYSFS_NAME_MAX = 64,
 IBV_SYSFS_PATH_MAX = 256
};

struct ibv_device {
 struct ibv_device_ops ops;
 int node_type;
 int transport_type;

 char name[IBV_SYSFS_NAME_MAX];

 char dev_name[IBV_SYSFS_NAME_MAX];

 char dev_path[IBV_SYSFS_PATH_MAX];

 char ibdev_path[IBV_SYSFS_PATH_MAX];
};

struct verbs_device {
 struct ibv_device device;
 size_t sz;
 size_t size_of_context;
 int (*init_context)(struct verbs_device *device,
    struct ibv_context *ctx, int cmd_fd);
 void (*uninit_context)(struct verbs_device *device,
    struct ibv_context *ctx);

};

struct ibv_context_ops {
 int (*query_device)(struct ibv_context *context,
           struct ibv_device_attr *device_attr);
 int (*query_port)(struct ibv_context *context, uint8_t port_num,
           struct ibv_port_attr *port_attr);
 struct ibv_pd * (*alloc_pd)(struct ibv_context *context);
 int (*dealloc_pd)(struct ibv_pd *pd);
 struct ibv_mr * (*reg_mr)(struct ibv_pd *pd, void *addr, size_t length,
       int access);
 struct ibv_mr * (*rereg_mr)(struct ibv_mr *mr,
         int flags,
         struct ibv_pd *pd, void *addr,
         size_t length,
         int access);
 int (*dereg_mr)(struct ibv_mr *mr);
 struct ibv_mw * (*alloc_mw)(struct ibv_pd *pd, int type);
 int (*bind_mw)(struct ibv_qp *qp, struct ibv_mw *mw,
        struct ibv_mw_bind *mw_bind);
 int (*dealloc_mw)(struct ibv_mw *mw);
 struct ibv_cq * (*create_cq)(struct ibv_context *context, int cqe,
          struct ibv_comp_channel *channel,
          int comp_vector);
 int (*poll_cq)(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc);
 int (*req_notify_cq)(struct ibv_cq *cq, int solicited_only);
 void (*cq_event)(struct ibv_cq *cq);
 int (*resize_cq)(struct ibv_cq *cq, int cqe);
 int (*destroy_cq)(struct ibv_cq *cq);
 struct ibv_srq * (*create_srq)(struct ibv_pd *pd,
           struct ibv_srq_init_attr *srq_init_attr);
 int (*modify_srq)(struct ibv_srq *srq,
           struct ibv_srq_attr *srq_attr,
           int srq_attr_mask);
 int (*query_srq)(struct ibv_srq *srq,
          struct ibv_srq_attr *srq_attr);
 int (*destroy_srq)(struct ibv_srq *srq);
 int (*post_srq_recv)(struct ibv_srq *srq,
       struct ibv_recv_wr *recv_wr,
       struct ibv_recv_wr **bad_recv_wr);
 struct ibv_qp * (*create_qp)(struct ibv_pd *pd, struct ibv_qp_init_attr *attr);
 int (*query_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr,
         int attr_mask,
         struct ibv_qp_init_attr *init_attr);
 int (*modify_qp)(struct ibv_qp *qp, struct ibv_qp_attr *attr,
          int attr_mask);
 int (*destroy_qp)(struct ibv_qp *qp);
 int (*post_send)(struct ibv_qp *qp, struct ibv_send_wr *wr,
          struct ibv_send_wr **bad_wr);
 int (*post_recv)(struct ibv_qp *qp, struct ibv_recv_wr *wr,
          struct ibv_recv_wr **bad_wr);
 struct ibv_ah * (*create_ah)(struct ibv_pd *pd, struct ibv_ah_attr *attr);
 int (*destroy_ah)(struct ibv_ah *ah);
 int (*attach_mcast)(struct ibv_qp *qp, const union ibv_gid *gid,
      uint16_t lid);
 int (*detach_mcast)(struct ibv_qp *qp, const union ibv_gid *gid,
      uint16_t lid);
 void (*async_event)(struct ibv_async_event *event);
};

struct ibv_context {
 struct ibv_device *device;
 struct ibv_context_ops ops;
 int cmd_fd;
 int async_fd;
 int num_comp_vectors;
 pthread_mutex_t mutex;
 void *abi_compat;
};

struct verbs_context {

 struct ibv_qp * (*open_qp)(struct ibv_context *context,
   struct ibv_qp_open_attr *attr);
 struct ibv_qp * (*create_qp_ex)(struct ibv_context *context,
   struct ibv_qp_init_attr_ex *qp_init_attr_ex);
 int (*get_srq_num)(struct ibv_srq *srq, uint32_t *srq_num);
 struct ibv_srq * (*create_srq_ex)(struct ibv_context *context,
   struct ibv_srq_init_attr_ex *srq_init_attr_ex);
 struct ibv_xrcd * (*open_xrcd)(struct ibv_context *context,
   struct ibv_xrcd_init_attr *xrcd_init_attr);
 int (*close_xrcd)(struct ibv_xrcd *xrcd);
 uint64_t has_comp_mask;
 size_t sz;
 struct ibv_context context;
};

static inline struct verbs_context *verbs_get_ctx(struct ibv_context *ctx)
{
 return (!ctx || (ctx->abi_compat != __VERBS_ABI_IS_EXTENDED)) ?
  ((void *)0) : ((struct verbs_context *) ((uint8_t *)(ctx) - __builtin_offsetof (struct verbs_context, context)));
}
static inline struct verbs_device *verbs_get_device(
     const struct ibv_device *dev)
{
 return (dev->ops.alloc_context) ?
  ((void *)0) : ((struct verbs_device *) ((uint8_t *)(dev) - __builtin_offsetof (struct verbs_device, device)));
}
struct ibv_device **ibv_get_device_list(int *num_devices);
void ibv_free_device_list(struct ibv_device **list);

const char *ibv_get_device_name(struct ibv_device *device);

uint64_t ibv_get_device_guid(struct ibv_device *device);

struct ibv_context *ibv_open_device(struct ibv_device *device);

int ibv_close_device(struct ibv_context *context);
int ibv_get_async_event(struct ibv_context *context,
   struct ibv_async_event *event);
void ibv_ack_async_event(struct ibv_async_event *event);

int ibv_query_device(struct ibv_context *context,
       struct ibv_device_attr *device_attr);

int ibv_query_port(struct ibv_context *context, uint8_t port_num,
     struct ibv_port_attr *port_attr);

static inline int ___ibv_query_port(struct ibv_context *context,
        uint8_t port_num,
        struct ibv_port_attr *port_attr)
{

 port_attr->link_layer = IBV_LINK_LAYER_UNSPECIFIED;
 port_attr->reserved = 0;

 return ibv_query_port(context, port_num, port_attr);
}

int ibv_query_gid(struct ibv_context *context, uint8_t port_num,
    int index, union ibv_gid *gid);

int ibv_query_pkey(struct ibv_context *context, uint8_t port_num,
     int index, uint16_t *pkey);

struct ibv_pd *ibv_alloc_pd(struct ibv_context *context);

int ibv_dealloc_pd(struct ibv_pd *pd);

static inline struct ibv_xrcd *
ibv_open_xrcd(struct ibv_context *context, struct ibv_xrcd_init_attr *xrcd_init_attr)
{
 struct verbs_context *vctx = ({ struct verbs_context *vctx = verbs_get_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context, open_xrcd)) || !vctx->open_xrcd) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 return vctx->open_xrcd(context, xrcd_init_attr);
}

static inline int ibv_close_xrcd(struct ibv_xrcd *xrcd)
{
 struct verbs_context *vctx = verbs_get_ctx(xrcd->context);
 return vctx->close_xrcd(xrcd);
}

struct ibv_mr *ibv_reg_mr(struct ibv_pd *pd, void *addr,
     size_t length, int access);

int ibv_dereg_mr(struct ibv_mr *mr);

static inline struct ibv_mw *ibv_alloc_mw(struct ibv_pd *pd,
  int type)
{
 if (!pd->context->ops.alloc_mw) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }

 struct ibv_mw *mw = pd->context->ops.alloc_mw(pd, type);
 if (mw) {
  mw->context = pd->context;
  mw->pd = pd;
 }
 return mw;
}

static inline int ibv_dealloc_mw(struct ibv_mw *mw)
{
 return mw->context->ops.dealloc_mw(mw);
}

static inline uint32_t ibv_inc_rkey(uint32_t rkey)
{
 const uint32_t mask = 0x000000ff;
 uint8_t newtag = (uint8_t) ((rkey + 1) & mask);
 return (rkey & ~mask) | newtag;
}

struct ibv_comp_channel *ibv_create_comp_channel(struct ibv_context *context);

int ibv_destroy_comp_channel(struct ibv_comp_channel *channel);
struct ibv_cq *ibv_create_cq(struct ibv_context *context, int cqe,
        void *cq_context,
        struct ibv_comp_channel *channel,
        int comp_vector);
int ibv_resize_cq(struct ibv_cq *cq, int cqe);

int ibv_destroy_cq(struct ibv_cq *cq);
int ibv_get_cq_event(struct ibv_comp_channel *channel,
       struct ibv_cq **cq, void **cq_context);
void ibv_ack_cq_events(struct ibv_cq *cq, unsigned int nevents);
static inline int ibv_poll_cq(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc)
{
 return cq->context->ops.poll_cq(cq, num_entries, wc);
}
static inline int ibv_req_notify_cq(struct ibv_cq *cq, int solicited_only)
{
 return cq->context->ops.req_notify_cq(cq, solicited_only);
}
struct ibv_srq *ibv_create_srq(struct ibv_pd *pd,
          struct ibv_srq_init_attr *srq_init_attr);

static inline struct ibv_srq *
ibv_create_srq_ex(struct ibv_context *context,
    struct ibv_srq_init_attr_ex *srq_init_attr_ex)
{
 struct verbs_context *vctx;
 uint32_t mask = srq_init_attr_ex->comp_mask;

 if (!(mask & ~(IBV_SRQ_INIT_ATTR_PD | IBV_SRQ_INIT_ATTR_TYPE)) &&
     (mask & IBV_SRQ_INIT_ATTR_PD) &&
     (!(mask & IBV_SRQ_INIT_ATTR_TYPE) ||
      (srq_init_attr_ex->srq_type == IBV_SRQT_BASIC)))
  return ibv_create_srq(srq_init_attr_ex->pd,
          (struct ibv_srq_init_attr *) srq_init_attr_ex);

 vctx = ({ struct verbs_context *vctx = verbs_get_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context, create_srq_ex)) || !vctx->create_srq_ex) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 return vctx->create_srq_ex(context, srq_init_attr_ex);
}
int ibv_modify_srq(struct ibv_srq *srq,
     struct ibv_srq_attr *srq_attr,
     int srq_attr_mask);

int ibv_query_srq(struct ibv_srq *srq, struct ibv_srq_attr *srq_attr);

static inline int ibv_get_srq_num(struct ibv_srq *srq, uint32_t *srq_num)
{
 struct verbs_context *vctx = ({ struct verbs_context *vctx = verbs_get_ctx(srq->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context, get_srq_num)) || !vctx->get_srq_num) ? ((void *)0) : vctx; });

 if (!vctx)
  return 38;

 return vctx->get_srq_num(srq, srq_num);
}

int ibv_destroy_srq(struct ibv_srq *srq);
static inline int ibv_post_srq_recv(struct ibv_srq *srq,
        struct ibv_recv_wr *recv_wr,
        struct ibv_recv_wr **bad_recv_wr)
{
 return srq->context->ops.post_srq_recv(srq, recv_wr, bad_recv_wr);
}

struct ibv_qp *ibv_create_qp(struct ibv_pd *pd,
        struct ibv_qp_init_attr *qp_init_attr);

static inline struct ibv_qp *
ibv_create_qp_ex(struct ibv_context *context, struct ibv_qp_init_attr_ex *qp_init_attr_ex)
{
 struct verbs_context *vctx;
 uint32_t mask = qp_init_attr_ex->comp_mask;

 if (mask == IBV_QP_INIT_ATTR_PD)
  return ibv_create_qp(qp_init_attr_ex->pd,
         (struct ibv_qp_init_attr *) qp_init_attr_ex);

 vctx = ({ struct verbs_context *vctx = verbs_get_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context, create_qp_ex)) || !vctx->create_qp_ex) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 return vctx->create_qp_ex(context, qp_init_attr_ex);
}

static inline struct ibv_qp *
ibv_open_qp(struct ibv_context *context, struct ibv_qp_open_attr *qp_open_attr)
{
 struct verbs_context *vctx = ({ struct verbs_context *vctx = verbs_get_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context, open_qp)) || !vctx->open_qp) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 return vctx->open_qp(context, qp_open_attr);
}

int ibv_modify_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,
    int attr_mask);
int ibv_query_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,
   int attr_mask,
   struct ibv_qp_init_attr *init_attr);

int ibv_destroy_qp(struct ibv_qp *qp);

static inline int ibv_post_send(struct ibv_qp *qp, struct ibv_send_wr *wr,
    struct ibv_send_wr **bad_wr)
{
 return qp->context->ops.post_send(qp, wr, bad_wr);
}

static inline int ibv_post_recv(struct ibv_qp *qp, struct ibv_recv_wr *wr,
    struct ibv_recv_wr **bad_wr)
{
 return qp->context->ops.post_recv(qp, wr, bad_wr);
}

struct ibv_ah *ibv_create_ah(struct ibv_pd *pd, struct ibv_ah_attr *attr);
int ibv_init_ah_from_wc(struct ibv_context *context, uint8_t port_num,
   struct ibv_wc *wc, struct ibv_grh *grh,
   struct ibv_ah_attr *ah_attr);
struct ibv_ah *ibv_create_ah_from_wc(struct ibv_pd *pd, struct ibv_wc *wc,
         struct ibv_grh *grh, uint8_t port_num);

int ibv_destroy_ah(struct ibv_ah *ah);
int ibv_attach_mcast(struct ibv_qp *qp, const union ibv_gid *gid, uint16_t lid);

int ibv_detach_mcast(struct ibv_qp *qp, const union ibv_gid *gid, uint16_t lid);

int ibv_fork_init(void);

const char *ibv_node_type_str(int node_type);

const char *ibv_port_state_str(int port_state);

const char *ibv_event_type_str(int event);

struct ibv_exp_device_calc_cap {
 uint64_t data_types;
 uint64_t data_sizes;
 uint64_t int_ops;
 uint64_t uint_ops;
 uint64_t fp_ops;
};

struct ibv_exp_device_attr {
 char fw_ver[64];
 uint64_t node_guid;
 uint64_t sys_image_guid;
 uint64_t max_mr_size;
 uint64_t page_size_cap;
 uint32_t vendor_id;
 uint32_t vendor_part_id;
 uint32_t hw_ver;
 int max_qp;
 int max_qp_wr;
 int reserved;
 int max_sge;
 int max_sge_rd;
 int max_cq;
 int max_cqe;
 int max_mr;
 int max_pd;
 int max_qp_rd_atom;
 int max_ee_rd_atom;
 int max_res_rd_atom;
 int max_qp_init_rd_atom;
 int max_ee_init_rd_atom;
 int exp_atomic_cap;
 int max_ee;
 int max_rdd;
 int max_mw;
 int max_raw_ipv6_qp;
 int max_raw_ethy_qp;
 int max_mcast_grp;
 int max_mcast_qp_attach;
 int max_total_mcast_qp_attach;
 int max_ah;
 int max_fmr;
 int max_map_per_fmr;
 int max_srq;
 int max_srq_wr;
 int max_srq_sge;
 uint16_t max_pkeys;
 uint8_t local_ca_ack_delay;
 uint8_t phys_port_cnt;
 uint32_t comp_mask;
 struct ibv_exp_device_calc_cap calc_cap;
 uint64_t timestamp_mask;
 uint64_t hca_core_clock;
 uint64_t exp_device_cap_flags;
 int max_dc_req_rd_atom;
 int max_dc_res_rd_atom;
 int inline_recv_sz;
 uint32_t max_rss_tbl_sz;
};

struct ibv_exp_mw_bind_info {
 struct ibv_mr *mr;
 uint64_t addr;
 uint64_t length;
 uint64_t exp_mw_access_flags;
};

struct ibv_exp_mw_bind {
 struct ibv_qp *qp;
 struct ibv_mw *mw;
 uint64_t wr_id;
 uint64_t exp_send_flags;
 struct ibv_exp_mw_bind_info bind_info;
 uint32_t comp_mask;
};

struct ibv_exp_send_wr {
 uint64_t wr_id;
 struct ibv_exp_send_wr *next;
 struct ibv_sge *sg_list;
 int num_sge;
 int exp_opcode;
 int reserved;
 union {
  uint32_t imm_data;
  uint32_t invalidate_rkey;
 } ex;
 union {
  struct {
   uint64_t remote_addr;
   uint32_t rkey;
  } rdma;
  struct {
   uint64_t remote_addr;
   uint64_t compare_add;
   uint64_t swap;
   uint32_t rkey;
  } atomic;
  struct {
   struct ibv_ah *ah;
   uint32_t remote_qpn;
   uint32_t remote_qkey;
  } ud;
 } wr;
 union {
  union {
   struct {
    uint32_t remote_srqn;
   } xrc;
  } qp_type;

  uint32_t xrc_remote_srq_num;
 };
 union {
  struct {
   uint64_t remote_addr;
   uint32_t rkey;
  } rdma;
  struct {
   uint64_t remote_addr;
   uint64_t compare_add;
   uint64_t swap;
   uint32_t rkey;
  } atomic;
  struct {
   struct ibv_cq *cq;
   int32_t cq_count;
  } cqe_wait;
  struct {
   struct ibv_qp *qp;
   int32_t wqe_count;
  } wqe_enable;
 } task;
 union {
  struct {
   int calc_op;
   int data_type;
   int data_size;
  } calc;
 } op;
 struct {
  struct ibv_ah *ah;
  uint64_t dct_access_key;
  uint32_t dct_number;
 } dc;
 struct {
  struct ibv_mw *mw;
  uint32_t rkey;
  struct ibv_exp_mw_bind_info bind_info;
 } bind_mw;
 uint64_t exp_send_flags;
 uint32_t comp_mask;
};

struct ibv_exp_values {
 uint32_t comp_mask;
 uint64_t hwclock_ns;
 uint64_t hwclock;
};

struct ibv_exp_cq_init_attr {
 uint32_t comp_mask;
 uint32_t flags;

};

struct ibv_exp_ah_attr {
 struct ibv_global_route grh;
 uint16_t dlid;
 uint8_t sl;
 uint8_t src_path_bits;
 uint8_t static_rate;
 uint8_t is_global;
 uint8_t port_num;
 uint32_t comp_mask;
 struct {
  int type;
  uint32_t len;
  char *address;
 } ll_address;
 uint16_t vid;
};

struct ibv_exp_qp_attr {
 int qp_state;
 int cur_qp_state;
 int path_mtu;
 int path_mig_state;
 uint32_t qkey;
 uint32_t rq_psn;
 uint32_t sq_psn;
 uint32_t dest_qp_num;
 int qp_access_flags;
 struct ibv_qp_cap cap;
 struct ibv_ah_attr ah_attr;
 struct ibv_ah_attr alt_ah_attr;
 uint16_t pkey_index;
 uint16_t alt_pkey_index;
 uint8_t en_sqd_async_notify;
 uint8_t sq_draining;
 uint8_t max_rd_atomic;
 uint8_t max_dest_rd_atomic;
 uint8_t min_rnr_timer;
 uint8_t port_num;
 uint8_t timeout;
 uint8_t retry_cnt;
 uint8_t rnr_retry;
 uint8_t alt_port_num;
 uint8_t alt_timeout;
 uint64_t dct_key;
 uint32_t comp_mask;
};

struct ibv_exp_qpg_init_attrib {
 uint32_t tss_child_count;
 uint32_t rss_child_count;
};

struct ibv_exp_qpg {
 uint32_t qpg_type;
 union {
  struct ibv_qp *qpg_parent;
  struct ibv_exp_qpg_init_attrib parent_attrib;
 };
};

struct ibv_exp_qp_init_attr {
 void *qp_context;
 struct ibv_cq *send_cq;
 struct ibv_cq *recv_cq;
 struct ibv_srq *srq;
 struct ibv_qp_cap cap;
 int qp_type;
 int sq_sig_all;

 uint32_t comp_mask;
 struct ibv_pd *pd;
 struct ibv_xrcd *xrcd;
 uint32_t exp_create_flags;

 uint32_t max_inl_recv;
 struct ibv_exp_qpg qpg;
};

struct ibv_exp_dct_init_attr {
 struct ibv_pd *pd;
 struct ibv_cq *cq;
 struct ibv_srq *srq;
 uint64_t dc_key;
 uint8_t port;
 uint32_t access_flags;
 uint8_t min_rnr_timer;
 uint8_t tclass;
 uint32_t flow_label;
 int mtu;
 uint8_t pkey_index;
 uint8_t gid_index;
 uint8_t hop_limit;
 uint32_t inline_size;
 uint32_t create_flags;
 uint32_t comp_mask;
};

struct ibv_exp_dct_attr {
 uint64_t dc_key;
 uint8_t port;
 uint32_t access_flags;
 uint8_t min_rnr_timer;
 uint8_t tclass;
 uint32_t flow_label;
 int mtu;
 uint8_t pkey_index;
 uint8_t gid_index;
 uint8_t hop_limit;
 uint32_t key_violations;
 uint8_t state;
 struct ibv_srq *srq;
 struct ibv_cq *cq;
 struct ibv_pd *pd;
 uint32_t comp_mask;
};

struct ibv_exp_port_attr {
 union {
  struct {
   int state;
   int max_mtu;
   int active_mtu;
   int gid_tbl_len;
   uint32_t port_cap_flags;
   uint32_t max_msg_sz;
   uint32_t bad_pkey_cntr;
   uint32_t qkey_viol_cntr;
   uint16_t pkey_tbl_len;
   uint16_t lid;
   uint16_t sm_lid;
   uint8_t lmc;
   uint8_t max_vl_num;
   uint8_t sm_sl;
   uint8_t subnet_timeout;
   uint8_t init_type_reply;
   uint8_t active_width;
   uint8_t active_speed;
   uint8_t phys_state;
   uint8_t link_layer;
   uint8_t reserved;
  };
  struct ibv_port_attr port_attr;
 };
 uint32_t comp_mask;
 uint32_t mask1;
};

struct ibv_exp_cq_attr {
 uint32_t comp_mask;
 struct {
  uint16_t cq_count;
  uint16_t cq_period;
 } moderation;
 uint32_t cq_cap_flags;
};

struct ibv_exp_reg_shared_mr_in {
 uint32_t mr_handle;
 struct ibv_pd *pd;
 void *addr;
 uint64_t exp_access;
 uint32_t comp_mask;
};

struct ibv_exp_flow_eth_filter {
 uint8_t dst_mac[6];
 uint8_t src_mac[6];
 uint16_t ether_type;

 uint16_t vlan_tag;
};

struct ibv_exp_flow_spec_eth {
 int type;
 uint16_t size;
 struct ibv_exp_flow_eth_filter val;
 struct ibv_exp_flow_eth_filter mask;
};

struct ibv_exp_flow_ib_filter {
 uint32_t qpn;
 uint8_t dst_gid[16];
};

struct ibv_exp_flow_spec_ib {
 int type;
 uint16_t size;
 struct ibv_exp_flow_ib_filter val;
 struct ibv_exp_flow_ib_filter mask;
};

struct ibv_exp_flow_ipv4_filter {
 uint32_t src_ip;
 uint32_t dst_ip;
};

struct ibv_exp_flow_spec_ipv4 {
 int type;
 uint16_t size;
 struct ibv_exp_flow_ipv4_filter val;
 struct ibv_exp_flow_ipv4_filter mask;
};

struct ibv_exp_flow_tcp_udp_filter {
 uint16_t dst_port;
 uint16_t src_port;
};

struct ibv_exp_flow_spec_tcp_udp {
 int type;
 uint16_t size;
 struct ibv_exp_flow_tcp_udp_filter val;
 struct ibv_exp_flow_tcp_udp_filter mask;
};

struct ibv_exp_flow_spec {
 union {
  struct {
   int type;
   uint16_t size;
  } hdr;
  struct ibv_exp_flow_spec_ib ib;
  struct ibv_exp_flow_spec_eth eth;
  struct ibv_exp_flow_spec_ipv4 ipv4;
  struct ibv_exp_flow_spec_tcp_udp tcp_udp;
 };
};

struct ibv_exp_flow_attr {
 int type;
 uint16_t size;
 uint16_t priority;
 uint8_t num_of_specs;
 uint8_t port;
 uint32_t flags;

 uint64_t reserved;
};

struct ibv_exp_flow {
 struct ibv_context *context;
 uint32_t handle;
};

struct ibv_exp_dct {
 struct ibv_context *context;
 uint32_t handle;
 uint32_t dct_num;
 struct ibv_pd *pd;
 struct ibv_srq *srq;
 struct ibv_cq *cq;
};

struct ibv_exp_wc {
 uint64_t wr_id;
 int status;
 int exp_opcode;
 uint32_t vendor_err;
 uint32_t byte_len;
 uint32_t imm_data;
 uint32_t qp_num;
 uint32_t src_qp;
 int reserved;
 uint16_t pkey_index;
 uint16_t slid;
 uint8_t sl;
 uint8_t dlid_path_bits;
 uint64_t timestamp;
 struct ibv_qp *qp;
 struct ibv_srq *srq;
 struct ibv_exp_dct *dct;
 uint64_t exp_wc_flags;
};

struct ibv_exp_reg_mr_in {
 struct ibv_pd *pd;
 void *addr;
 size_t length;
 uint64_t exp_access;
 uint32_t comp_mask;
};

struct ibv_exp_task {
 int task_type;
 struct {
  struct ibv_qp *qp;
  union {
   struct ibv_exp_send_wr *send_wr;
   struct ibv_recv_wr *recv_wr;
  };
 } item;
 struct ibv_exp_task *next;
 uint32_t comp_mask;
};

struct ibv_exp_arm_attr {
 uint32_t comp_mask;
};

struct verbs_context_exp {

 int (*drv_exp_arm_dct)(struct ibv_exp_dct *dct, struct ibv_exp_arm_attr *attr);
 int (*lib_exp_arm_dct)(struct ibv_exp_dct *dct, struct ibv_exp_arm_attr *attr);
 int (*drv_exp_bind_mw)(struct ibv_exp_mw_bind *mw_bind);
 int (*lib_exp_bind_mw)(struct ibv_exp_mw_bind *mw_bind);
 int (*drv_exp_post_send)(struct ibv_qp *qp,
     struct ibv_exp_send_wr *wr,
     struct ibv_exp_send_wr **bad_wr);
 struct ibv_mr * (*drv_exp_reg_mr)(struct ibv_exp_reg_mr_in *in);
 struct ibv_mr * (*lib_exp_reg_mr)(struct ibv_exp_reg_mr_in *in);
 struct ibv_ah * (*drv_exp_ibv_create_ah)(struct ibv_pd *pd,
       struct ibv_exp_ah_attr *attr_exp);
 int (*drv_exp_query_values)(struct ibv_context *context, int q_values,
        struct ibv_exp_values *values);
 struct ibv_cq * (*exp_create_cq)(struct ibv_context *context, int cqe,
      struct ibv_comp_channel *channel,
      int comp_vector, struct ibv_exp_cq_init_attr *attr);
 int (*drv_exp_ibv_poll_cq)(struct ibv_cq *ibcq, int num_entries,
       struct ibv_exp_wc *wc, uint32_t wc_size);
 void * (*drv_exp_get_legacy_xrc) (struct ibv_srq *ibv_srq);
 void (*drv_exp_set_legacy_xrc) (struct ibv_srq *ibv_srq, void *legacy_xrc);
 struct ibv_mr * (*drv_exp_ibv_reg_shared_mr)(struct ibv_exp_reg_shared_mr_in *in);
 struct ibv_mr * (*lib_exp_ibv_reg_shared_mr)(struct ibv_exp_reg_shared_mr_in *in);
 int (*drv_exp_modify_qp)(struct ibv_qp *qp, struct ibv_exp_qp_attr *attr,
     uint64_t exp_attr_mask);
 int (*lib_exp_modify_qp)(struct ibv_qp *qp, struct ibv_exp_qp_attr *attr,
     uint64_t exp_attr_mask);
 int (*drv_exp_post_task)(struct ibv_context *context,
     struct ibv_exp_task *task,
     struct ibv_exp_task **bad_task);
 int (*lib_exp_post_task)(struct ibv_context *context,
     struct ibv_exp_task *task,
     struct ibv_exp_task **bad_task);
 int (*drv_exp_modify_cq)(struct ibv_cq *cq,
     struct ibv_exp_cq_attr *attr, int attr_mask);
 int (*lib_exp_modify_cq)(struct ibv_cq *cq,
     struct ibv_exp_cq_attr *attr, int attr_mask);
 int (*drv_exp_ibv_destroy_flow) (struct ibv_exp_flow *flow);
 int (*lib_exp_ibv_destroy_flow) (struct ibv_exp_flow *flow);
 struct ibv_exp_flow * (*drv_exp_ibv_create_flow) (struct ibv_qp *qp,
            struct ibv_exp_flow_attr
            *flow_attr);
 struct ibv_exp_flow * (*lib_exp_ibv_create_flow) (struct ibv_qp *qp,
         struct ibv_exp_flow_attr
         *flow_attr);

 int (*drv_exp_query_port)(struct ibv_context *context, uint8_t port_num,
      struct ibv_exp_port_attr *port_attr);
 int (*lib_exp_query_port)(struct ibv_context *context, uint8_t port_num,
      struct ibv_exp_port_attr *port_attr);
 struct ibv_exp_dct *(*create_dct)(struct ibv_context *context,
       struct ibv_exp_dct_init_attr *attr);
 int (*destroy_dct)(struct ibv_exp_dct *dct);
 int (*query_dct)(struct ibv_exp_dct *dct, struct ibv_exp_dct_attr *attr);
 int (*drv_exp_query_device)(struct ibv_context *context,
        struct ibv_exp_device_attr *attr);
 int (*lib_exp_query_device)(struct ibv_context *context,
        struct ibv_exp_device_attr *attr);
 struct ibv_qp *(*drv_exp_create_qp)(struct ibv_context *context,
         struct ibv_exp_qp_init_attr *init_attr);
 struct ibv_qp *(*lib_exp_create_qp)(struct ibv_context *context,
         struct ibv_exp_qp_init_attr *init_attr);
 size_t sz;

};

static inline struct verbs_context_exp *verbs_get_exp_ctx(struct ibv_context *ctx)
{
 size_t sz;
 struct verbs_context *vctx = verbs_get_ctx(ctx);

 if (!vctx || !(vctx->has_comp_mask & VERBS_CONTEXT_EXP))
  return ((void *)0);
 sz = *(size_t *)(((char *)vctx) - sizeof(size_t));
 return (struct verbs_context_exp *)(((char *)vctx) - sz);
}
static inline struct ibv_qp *
ibv_exp_create_qp(struct ibv_context *context, struct ibv_exp_qp_init_attr *qp_init_attr)
{
 struct verbs_context_exp *vctx;
 uint32_t mask = qp_init_attr->comp_mask;

 if (mask == IBV_EXP_QP_INIT_ATTR_PD)
  return ibv_create_qp(qp_init_attr->pd,
         (struct ibv_qp_init_attr *) qp_init_attr);

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_create_qp)) || !vctx->lib_exp_create_qp) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 if (qp_init_attr->comp_mask > (IBV_EXP_QP_INIT_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, qp_init_attr->comp_mask, IBV_EXP_QP_INIT_ATTR_RESERVED - 1); qp_init_attr->comp_mask = 0; };

 return vctx->lib_exp_create_qp(context, qp_init_attr);
}

static inline int ibv_exp_query_device(struct ibv_context *context,
           struct ibv_exp_device_attr *attr)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_query_device)) || !vctx->lib_exp_query_device) ? ((void *)0) : vctx; })
                                  ;
 if (!vctx)
  return 38;

 if (attr->comp_mask > (IBV_EXP_DEVICE_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, attr->comp_mask, IBV_EXP_DEVICE_ATTR_RESERVED - 1); attr->comp_mask = 0; };
 return vctx->lib_exp_query_device(context, attr);
}

static inline struct ibv_exp_dct *
ibv_exp_create_dct(struct ibv_context *context,
     struct ibv_exp_dct_init_attr *attr)
{
 struct verbs_context_exp *vctx;
 struct ibv_exp_dct *dct;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, create_dct)) || !vctx->create_dct) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }

 pthread_mutex_lock(&context->mutex);
 if (attr->comp_mask > (IBV_EXP_DCT_INIT_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, attr->comp_mask, IBV_EXP_DCT_INIT_ATTR_RESERVED - 1); attr->comp_mask = 0; };
 dct = vctx->create_dct(context, attr);
 if (dct)
  dct->context = context;

 pthread_mutex_unlock(&context->mutex);

 return dct;
}

static inline int ibv_exp_destroy_dct(struct ibv_exp_dct *dct)
{
 struct verbs_context_exp *vctx;
 struct ibv_context *context = dct->context;
 int err;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, destroy_dct)) || !vctx->destroy_dct) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return (*__errno_location ());
 }

 pthread_mutex_lock(&context->mutex);
 err = vctx->destroy_dct(dct);
 pthread_mutex_unlock(&context->mutex);

 return err;
}

static inline int ibv_exp_query_dct(struct ibv_exp_dct *dct,
        struct ibv_exp_dct_attr *attr)
{
 struct verbs_context_exp *vctx;
 struct ibv_context *context = dct->context;
 int err;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, query_dct)) || !vctx->query_dct) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return (*__errno_location ());
 }

 pthread_mutex_lock(&context->mutex);
 if (attr->comp_mask > (IBV_EXP_DCT_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, attr->comp_mask, IBV_EXP_DCT_ATTR_RESERVED - 1); attr->comp_mask = 0; };
 err = vctx->query_dct(dct, attr);
 pthread_mutex_unlock(&context->mutex);

 return err;
}

static inline int ibv_exp_arm_dct(struct ibv_exp_dct *dct,
      struct ibv_exp_arm_attr *attr)
{
 struct verbs_context_exp *vctx;
 struct ibv_context *context = dct->context;
 int err;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_arm_dct)) || !vctx->lib_exp_arm_dct) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return (*__errno_location ());
 }

 pthread_mutex_lock(&context->mutex);
 if (attr->comp_mask > (IBV_EXP_ARM_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, attr->comp_mask, IBV_EXP_ARM_ATTR_RESERVED - 1); attr->comp_mask = 0; };
 err = vctx->lib_exp_arm_dct(dct, attr);
 pthread_mutex_unlock(&context->mutex);

 return err;
}

static inline int ibv_exp_query_port(struct ibv_context *context,
         uint8_t port_num,
         struct ibv_exp_port_attr *port_attr)
{
 struct verbs_context_exp *vctx;

 if (0 == port_attr->comp_mask)
  return ___ibv_query_port(context, port_num, &port_attr->port_attr)
                                ;

 if ((!port_attr->comp_mask & IBV_EXP_QUERY_PORT_ATTR_MASK1) ||
     (port_attr->comp_mask & ~IBV_EXP_QUERY_PORT_ATTR_MASKS) ||
     (port_attr->mask1 & ~IBV_EXP_QUERY_PORT_MASK)) {
  (*__errno_location ()) = 22;
  return -(*__errno_location ());
 }

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_query_port)) || !vctx->lib_exp_query_port) ? ((void *)0) : vctx; });

 if (!vctx) {

  if (port_attr->comp_mask == IBV_EXP_QUERY_PORT_ATTR_MASK1 &&
      !(port_attr->mask1 & ~IBV_EXP_QUERY_PORT_STD_MASK))
   return ___ibv_query_port(context, port_num, &port_attr->port_attr)
                                 ;

  (*__errno_location ()) = 38;
  return -(*__errno_location ());
 }
 if (port_attr->comp_mask > (IBV_EXP_QUERY_PORT_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, port_attr->comp_mask, IBV_EXP_QUERY_PORT_ATTR_RESERVED - 1); port_attr->comp_mask = 0; };

 return vctx->lib_exp_query_port(context, port_num, port_attr);
}

static inline int ibv_exp_post_task(struct ibv_context *context,
        struct ibv_exp_task *task,
        struct ibv_exp_task **bad_task)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_post_task)) || !vctx->lib_exp_post_task) ? ((void *)0) : vctx; })
                               ;
 if (!vctx)
  return 38;

 if (task->comp_mask > (IBV_EXP_TASK_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, task->comp_mask, IBV_EXP_TASK_RESERVED - 1); task->comp_mask = 0; };

 return vctx->lib_exp_post_task(context, task, bad_task);
}

static inline int ibv_exp_query_values(struct ibv_context *context, int q_values,
           struct ibv_exp_values *values)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, drv_exp_query_values)) || !vctx->drv_exp_query_values) ? ((void *)0) : vctx; })
                                  ;
 if (!vctx) {
  (*__errno_location ()) = 38;
  return -(*__errno_location ());
 }
 if (values->comp_mask > (IBV_EXP_VALUES_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, values->comp_mask, IBV_EXP_VALUES_RESERVED - 1); values->comp_mask = 0; };

 return vctx->drv_exp_query_values(context, q_values, values);
}

static inline struct ibv_exp_flow *ibv_exp_create_flow(struct ibv_qp *qp,
             struct ibv_exp_flow_attr *flow)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(qp->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_ibv_create_flow)) || !vctx->lib_exp_ibv_create_flow) ? ((void *)0) : vctx; })
                                     ;
 if (!vctx || !vctx->lib_exp_ibv_create_flow)
  return ((void *)0);

 if (flow->reserved != 0L) {
  fprintf(stderr, "%s:%d: flow->reserved must be 0\n", __FUNCTION__, 1272);
  flow->reserved = 0L;
 }

 return vctx->lib_exp_ibv_create_flow(qp, flow);
}

static inline int ibv_exp_destroy_flow(struct ibv_exp_flow *flow_id)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(flow_id->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_ibv_destroy_flow)) || !vctx->lib_exp_ibv_destroy_flow) ? ((void *)0) : vctx; })
                                      ;
 if (!vctx || !vctx->lib_exp_ibv_destroy_flow)
  return -38;

 return vctx->lib_exp_ibv_destroy_flow(flow_id);
}

static inline int ibv_exp_poll_cq(struct ibv_cq *ibcq, int num_entries,
      struct ibv_exp_wc *wc, uint32_t wc_size)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(ibcq->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, drv_exp_ibv_poll_cq)) || !vctx->drv_exp_ibv_poll_cq) ? ((void *)0) : vctx; })
                                 ;
 if (!vctx)
  return -38;

 return vctx->drv_exp_ibv_poll_cq(ibcq, num_entries, wc, wc_size);
}

static inline int ibv_exp_post_send(struct ibv_qp *qp,
        struct ibv_exp_send_wr *wr,
        struct ibv_exp_send_wr **bad_wr)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(qp->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, drv_exp_post_send)) || !vctx->drv_exp_post_send) ? ((void *)0) : vctx; })
                               ;
 if (!vctx)
  return -38;

 return vctx->drv_exp_post_send(qp, wr, bad_wr);
}

static inline struct ibv_mr *ibv_exp_reg_shared_mr(struct ibv_exp_reg_shared_mr_in *mr_in)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(mr_in->pd->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_ibv_reg_shared_mr)) || !vctx->lib_exp_ibv_reg_shared_mr) ? ((void *)0) : vctx; })
                                       ;
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 if (mr_in->comp_mask > (IBV_EXP_REG_SHARED_MR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, mr_in->comp_mask, IBV_EXP_REG_SHARED_MR_RESERVED - 1); mr_in->comp_mask = 0; };

 return vctx->lib_exp_ibv_reg_shared_mr(mr_in);
}
static inline int ibv_exp_modify_cq(struct ibv_cq *cq,
        struct ibv_exp_cq_attr *cq_attr,
        int cq_attr_mask)
{
 struct verbs_context_exp *vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(cq->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_modify_cq)) || !vctx->lib_exp_modify_cq) ? ((void *)0) : vctx; })
                               ;
 if (!vctx)
  return 38;

 if (cq_attr->comp_mask > (IBV_EXP_CQ_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, cq_attr->comp_mask, IBV_EXP_CQ_ATTR_RESERVED - 1); cq_attr->comp_mask = 0; };

 return vctx->lib_exp_modify_cq(cq, cq_attr, cq_attr_mask);
}

static inline struct ibv_cq *ibv_exp_create_cq(struct ibv_context *context,
            int cqe,
            void *cq_context,
            struct ibv_comp_channel *channel,
            int comp_vector,
            struct ibv_exp_cq_init_attr *attr)
{
 struct verbs_context_exp *vctx;
 struct ibv_cq *cq;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, exp_create_cq)) || !vctx->exp_create_cq) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }

 pthread_mutex_lock(&context->mutex);
 if (attr->comp_mask > (IBV_EXP_CQ_INIT_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, attr->comp_mask, IBV_EXP_CQ_INIT_ATTR_RESERVED - 1); attr->comp_mask = 0; };
 cq = vctx->exp_create_cq(context, cqe, channel, comp_vector, attr);
 if (cq) {
  cq->context = context;
  cq->channel = channel;
  if (channel)
   ++channel->refcnt;
  cq->cq_context = cq_context;
  cq->comp_events_completed = 0;
  cq->async_events_completed = 0;
  pthread_mutex_init(&cq->mutex, ((void *)0));
  pthread_cond_init(&cq->cond, ((void *)0));
 }

 pthread_mutex_unlock(&context->mutex);

 return cq;
}

static inline int
ibv_exp_modify_qp(struct ibv_qp *qp, struct ibv_exp_qp_attr *attr, uint64_t exp_attr_mask)
{
 struct verbs_context_exp *vctx;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(qp->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_modify_qp)) || !vctx->lib_exp_modify_qp) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return (*__errno_location ());
 }
 if (attr->comp_mask > (IBV_EXP_QP_ATTR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, attr->comp_mask, IBV_EXP_QP_ATTR_RESERVED - 1); attr->comp_mask = 0; };

 return vctx->lib_exp_modify_qp(qp, attr, exp_attr_mask);
}

static inline struct ibv_mr *ibv_exp_reg_mr(struct ibv_exp_reg_mr_in *in)
{
 struct verbs_context_exp *vctx;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(in->pd->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_reg_mr)) || !vctx->lib_exp_reg_mr) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return ((void *)0);
 }
 if (in->comp_mask > (IBV_EXP_REG_MR_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, in->comp_mask, IBV_EXP_REG_MR_RESERVED - 1); in->comp_mask = 0; };

 return vctx->lib_exp_reg_mr(in);
}

static inline int ibv_exp_bind_mw(struct ibv_exp_mw_bind *mw_bind)
{
 struct verbs_context_exp *vctx;

 vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(mw_bind->mw->context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, lib_exp_bind_mw)) || !vctx->lib_exp_bind_mw) ? ((void *)0) : vctx; });
 if (!vctx) {
  (*__errno_location ()) = 38;
  return (*__errno_location ());
 }
 if (mw_bind->comp_mask > (IBV_EXP_BIND_MW_RESERVED - 1)) { fprintf(stderr, "%s: resetting invalid comp_mask !!! (comp_mask = 0x%x valid_mask = 0x%x)\n", __FUNCTION__, mw_bind->comp_mask, IBV_EXP_BIND_MW_RESERVED - 1); mw_bind->comp_mask = 0; };

 return vctx->lib_exp_bind_mw(mw_bind);
}

typedef int (*drv_exp_post_send_func)(struct ibv_qp *qp,
     struct ibv_exp_send_wr *wr,
     struct ibv_exp_send_wr **bad_wr);
typedef int (*drv_post_send_func)(struct ibv_qp *qp, struct ibv_send_wr *wr,
    struct ibv_send_wr **bad_wr);
typedef int (*drv_exp_poll_cq_func)(struct ibv_cq *ibcq, int num_entries,
       struct ibv_exp_wc *wc, uint32_t wc_size);
typedef int (*drv_poll_cq_func)(struct ibv_cq *cq, int num_entries, struct ibv_wc *wc);
typedef int (*drv_post_recv_func)(struct ibv_qp *qp, struct ibv_recv_wr *wr,
    struct ibv_recv_wr **bad_wr);

static inline void *ibv_exp_get_provider_func(struct ibv_context *context,
      int name)
{
 struct verbs_context_exp *vctx;

 switch (name) {
 case IBV_EXP_POST_SEND_FUNC:
  vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, drv_exp_post_send)) || !vctx->drv_exp_post_send) ? ((void *)0) : vctx; });
  if (!vctx)
   goto error;

  return (void *)vctx->drv_exp_post_send;

 case IBV_EXP_POLL_CQ_FUNC:
  vctx = ({ struct verbs_context_exp *vctx = verbs_get_exp_ctx(context); (!vctx || (vctx->sz < sizeof(*vctx) - __builtin_offsetof (struct verbs_context_exp, drv_exp_ibv_poll_cq)) || !vctx->drv_exp_ibv_poll_cq) ? ((void *)0) : vctx; });
  if (!vctx)
   goto error;

  return (void *)vctx->drv_exp_ibv_poll_cq;

 case IBV_POST_SEND_FUNC:
  if (!context->ops.post_send)
   goto error;

  return (void *)context->ops.post_send;

 case IBV_POLL_CQ_FUNC:
  if (!context->ops.poll_cq)
   goto error;

  return (void *)context->ops.poll_cq;

 case IBV_POST_RECV_FUNC:
  if (!context->ops.post_recv)
   goto error;

  return (void *)context->ops.post_recv;

 default:
  break;
 }

error:
 (*__errno_location ()) = 38;
 return ((void *)0);
}

]=============]
